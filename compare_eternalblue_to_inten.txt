Below is a high-level comparison of this simple, deliberately insecure, “SMBv2-like” backdoor demonstration versus the real EternalBlue exploit. While they share the broad theme of leveraging SMB protocol weaknesses for remote code execution, EternalBlue was significantly more complex and targeted different underlying bugs.

1. Protocol Version and Scope
	•	Educational Demo (Above):
	•	Fakes an “SMBv2-like” protocol but omits most fields, authentication steps, dialect negotiation, session setup, signing, etc.
	•	Intentionally adds a hidden backdoor command (0xFFFF) that trivially overwrites a function pointer.
	•	EternalBlue:
	•	Exploited SMBv1 (Server Message Block version 1) on Windows systems (though there were elements of SMBv2-related patches, the core bug was in SMBv1 code paths).
	•	Was not a simple, deliberate backdoor; rather, it took advantage of an unintended memory corruption vulnerability in Microsoft’s SMB server driver (srv.sys / srv2.sys variants).

2. Vulnerability Type
	•	Educational Demo (Above):
	•	Shows a contrived, deliberate hidden command that overwrites a function pointer on the stack.
	•	No real-depth memory parsing errors; it’s just an “if command == 0xFFFF, overwrite pointer” logic.
	•	EternalBlue:
	•	Abused a buffer-overrun (or buffer length parsing) flaw in the Windows SMB driver.
	•	The exploit allowed remote attackers to corrupt kernel memory structures in a way that eventually gave them arbitrary code execution in the Windows kernel.
	•	Involved complicated manipulations to trigger the out-of-bounds write in a part of SMB transaction processing.

3. Complexity and Exploitation Techniques
	•	Educational Demo (Above):
	•	Extremely straightforward “exploit flow”:
	1.	Send a packet with the “secret command.”
	2.	Copy your chosen function pointer to the stack variable.
	3.	Call that pointer directly.
	•	No advanced obfuscation, ROP chains, or address leaks. You just supply the address you want to call.
	•	EternalBlue:
	•	Used advanced techniques to spray and groom memory to ensure specific kernel data structures or function pointers ended up at predictable locations.
	•	Bypassed kernel defenses like DEP/NX (Data Execution Prevention) and had to work around ASLR (Address Space Layout Randomization).
	•	Often paired with a secondary “DoublePulsar” backdoor that allowed further code injection once the initial exploitation succeeded.

4. Real-World Impact vs. Demonstration
	•	Educational Demo (Above):
	•	Purely for illustrative teaching: “Here is a hidden command that trivially overwrites a pointer.”
	•	Obviously insecure and not patched—it’s meant to show how any leftover debug or hidden logic can become a backdoor.
	•	EternalBlue:
	•	Had massive real-world impact, most famously used in the WannaCry ransomware outbreak (May 2017).
	•	Spread within local networks (and across the Internet) to any unpatched Windows machine running SMBv1.
	•	Forced Microsoft to release emergency patches, even for end-of-life systems like Windows XP.

5. Code Anatomy and Attack Surface
	•	Educational Demo (Above):
	•	A single .c file for the server, another for the “malicious client,” with all details shown in clear text.
	•	The server code is barely 200 lines, obviously insecure: no length checks, no real authentication, a direct pointer copy from user data.
	•	EternalBlue:
	•	Decompiling or reverse-engineering the original NSA exploit code (later leaked by “The Shadow Brokers”) showed a far more elaborate “back-end” needed to:
	1.	Fingerprint the target Windows version/build.
	2.	Dynamically construct or select the right exploit payload based on OS version.
	3.	Deploy a staging shellcode that would gain kernel privileges.
	•	Microsoft’s actual SMBv1 code is tens of thousands of lines of C (plus kernel/hook code) with many layers of complexity.

6. Address Location and ASLR Bypassing
	•	Educational Demo (Above):
	•	Simply pass in an address on the command line (like 0x00401126), rely on the server to have no ASLR or to be “statically compiled” in a VM.
	•	This is obviously unrealistic for most production scenarios; real systems almost always have ASLR enabled.
	•	EternalBlue:
	•	Required sophisticated heap-spraying (or “heap grooming”) to create predictable memory layouts in Windows’ kernel pool allocations.
	•	Attackers had to figure out how to leak or guess kernel memory addresses so they could place the exploit data where it would eventually be executed.

7. Underlying Design vs. Unintended Bug
	•	Educational Demo (Above):
	•	Purposefully introduced a hidden command that overwrote a pointer—this is more like an intentional backdoor than a bug.
	•	EternalBlue:
	•	Stemmed from a genuine bug in Microsoft’s implementation of SMBv1.
	•	The bug was not intentionally placed; it was an oversight in how certain request lengths and buffer offsets were validated.

8. Summary of Key Differences
	1.	Protocol: The real exploit hit SMBv1 (specifically in Windows srv.sys), while this demo pretends to be an “SMBv2-like” skeleton.
	2.	Vulnerability: EternalBlue was a complex buffer overrun in kernel code; this demo is an intentional “backdoor command” + pointer overwrite.
	3.	Exploit Sophistication: EternalBlue used advanced memory manipulation, shellcode injection, and address leaks to bypass protections; the demo just copies user-supplied data to a function pointer.
	4.	Impact: EternalBlue had global consequences (WannaCry, NotPetya, etc.). This demo is for local learning only, showing a simplified remote code execution scenario.

Final Takeaway

Real EternalBlue required:
	•	A legitimate (though vulnerable) code path in SMBv1,
	•	Detailed knowledge of Windows kernel internals,
	•	Techniques to bypass ASLR and DEP in the wild,
	•	Compatibility with numerous Windows versions.

Conversely, this demo:
	•	Illustrates the concept of “hidden backdoors + pointer overwrites” in a minimal, contrived example,
	•	Leaves out almost every real-world safeguard,
	•	Doesn’t reflect the actual complexities or mitigations found in SMB or modern operating systems.

Both revolve around remote code execution via SMB, but the real EternalBlue is vastly more intricate, was not intentionally placed as a backdoor, and had enormous real-world fallout.